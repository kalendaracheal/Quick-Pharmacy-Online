<!DOCTYPE html>
<html lang="en">

<head>

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="">
  <meta name="author" content="">

  <title>Queues</title>

  <!-- Custom fonts for this template-->
  <link href="vendor/fontawesome-free/css/all.min.css" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Nunito:200,200i,300,300i,400,400i,600,600i,700,700i,800,800i,900,900i" rel="stylesheet">

  <!-- Custom styles for this template-->
  <link href="css/sb-admin-2.min.css" rel="stylesheet">

</head>

<body id="page-top" style="background-color: aliceblue;">



<div>
  <h1 style="color: red;text-align: center;">Data structures and 
    Algorithms 
    </h1>

    <h2 style="color: red;font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;">Queues</h2>

    <h4 style="font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;"> What is a queue?</h4>
    <p style="font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;">It is an ordered group of homogeneous items of elements. </p>
    <h4 style="font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;">Queues have two ends</h4>
    <ul style="font-family: cursive;">
      <li>Elements are added at one end called the rear.</li>
      <li>Elements are removed from the other end called the front.  </li>
      <li> <b>
        The element added first is also removed first (FIFO: First 
        In, First Out). </b>
        </li>

    </ul>
    <h4 style="color: red;font-family: Verdana, Geneva, Tahoma, sans-serif;"> The Queue ADT</h4>
    <ul style="font-family: cursive;">
      <li><b> queue operations are given below</b></li>
      <li><b style="color: blue;">Queue() </b>creates a new queue that is empty. It needs 
        no parameters and returns an empty queue. 
        </li>
        <li><b style="color: blue;">enqueue(item) </b>adds a new item to the rear of the queue. It needs the item and returns nothing. 
          </li>
          
          <li><b style="color: blue;">dequeue() </b>removes the front item from the queue. 
            It needs no parameters and returns the item. The queue is modified. 
        </li>

        <li><b style="color: blue;">is_empty() </b>tests to see whether the queue is empty. It needs no parameters and returns a Boolean value. 
      </li>

      
      <li><b style="color: blue;">size() </b>returns the number of items in the queue. It needs no parameters and returns an integer. </li>

    </ul>
    <h4 style="color: red;font-family: Verdana, Geneva, Tahoma, sans-serif;">Queues in computer science</h4>
    <ol style="font-family: cursive;font-size: larger;">Operating systems: 
      <ul>
      <li>queue of print jobs to send to the printer </li>
      <li>queue of programs / processes to be run </li>
      <li>queue of network data packets to send </li>  
    
    </ul>
  </ol>
  <ol style="font-family: cursive;font-size: larger;">Programming: 
    <ul>
    <li>modeling a line of customers or clients </li>
    <li>storing a queue of computations to be performed in order  </li>
    <li>people on an escalator or waiting in a line  </li> 
    <li> cars at a gas station (or on an assembly line)  </li> 
  
  </ul>
</ol>

<h3 style="color: red;font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;">Application of Queues</h3>
<ul style="font-family: cursive;font-size: larger;">
 <li> Printing Job Management </li>
 <li> Packet Forwarding in Routers</li>
 <li>Message queue in Windows </li>
<li> I/O buffer</li>
</ul>

<h3 style="color: red;font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;">Array implementation of queues </h3>
<ul style="font-family: cursive;font-size: larger;">
 <li>A queue is a first in, first out (FIFO) data structure  </li>
 <li> This is accomplished by inserting at one end (the rear) and deleting from the other (the front) </li>
 <li><b>To insert:</b> put new element in location 4, and set rear to 4</li>
<li><b>To delete: </b>take element from location 0, and set front to 1 </li>
</ul>

<h3 style="color: red;font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;">Array implementation of queues using circular arrays </h3>
<ul style="font-family: cursive;font-size: larger;">
 <li>  As we have seen, in case of linear queue the elements get deleted logically as in this figure below </li>
 <li>  We have deleted the elements 10, 20 and 30 means simply 
  the front pointer is shifted ahead. 
  </li>
 <li>Now if we try to insert any more element then it won’t be 
  possible as it is going to give ‘queue full’ message. Although 
  there is a space of elements 10, 20 and 30 (these are 
  deleted elements) we cannot utilize them because queue is 
  nothing but a linear array. 
  </li>
<li>The concept of circular queue, has the main advantage of 
  utilizing the space of the queue fully.
   </li>
</ul>

<h3 style="color: red;font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;">Circulars Arrays </h3>
<ul style="font-family: cursive;font-size: larger;">
  <li> We can treat the array holding the queue elements 
    as circular (joined at the ends) 
     </li>
  <li>Elements were added to this queue in the order 
    11, 22, 33, 44, 55, and will be removed in the same 
    order 
     
   </li>
  <li>Use: <p style="color: blue; "> front = (front + 1) % myQueue.length; 
    and: rear = (rear + 1) % myQueue.length; 
    44 <br> 
    55 <br>
    11 <br>
    22 <br>
    33 <br>
    0 1 2 3 4 5 6 7 <br>
    myQueue: <br>
    rear = 1 <br>
    front = 5 
  </p>
     
   </li>
 <li> If the queue were to become completely full, it 
  would look like this:
     </li>
     <li> If we were then to remove all eight elements, making the queue completely empty, it would look like this: <br>
      <p style="color: blue;">
      44 <br>
      55 <br>
      66 <br>
      77 <br>
      88 <br>
      11 <br>
      22 <br>
      33 <br>
      0 1 2 3 4 5 6 7 <br>
      myQueue: <br>
      rear = 4 <br>
      front = 5 <br>
      0 1 2 3 4 5 6 7 <br>
      myQueue: <br>
      rear = 4 <br>
      front = 5 <br>
    </p>
      This is a problem! 
        
    </li>
 
 <h3 style="color: red;font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;">Full and empty queue: solutions </h3>
  <li>Solution #1: Keep an additional variable </li>
<li>Solution #2: (Slightly more efficient) Keep a gap 
  between elements: consider the queue full when it has 
  n-1 elements
  </li>
  <p style="color: blue;">44 <br>
    55 <br>
    66 <br>
    77 <br>
    88 <br>
    11 <br>
    22 <br>
    33 <br>
    0 1 2 3 4 5 6 7 <br>
    myQueue: <br>
    rear = 4 <br>
    front = 5 <br>
    count = 8 <br>
    44 <br>
    55 <br>
    66 <br>
    77 <br>
    11 <br>
    22 <br>
    33 <br>
    0 1 2 3 4 5 6 7 <br>
    myQueue: <br>
    rear = 3 <br>
    front = 5 
    </p>
    <h3 style="color: red;font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;">Implementation of queues using linked lists </h3>
 <li>Allocate memory for each new element dynamically</li>
 <li>Link the queue elements together</li>
 <li>Use two pointers, qFront and qRear, to mark the front and 
  rear of the queue 
  </li>
  <h2 style="color: red;">Linked-list implementation of queues </h2>
<li>In a queue, insertions occur at one end, deletions at the other 
  end 
  </li>
  <li>Operations at the front of a singly-linked list (SLL) are O(1), 
    but at the other end they are O(n) 
    </li>
    Because you have to find the last element each time 
    <li>• BUT: there is a simple way to use a singly-linked list to 
      implement both insertions and deletions in O(1) time 
      </li>
    You always need a pointer to the first thing in the list 
You can keep an additional pointer to the last thing in the 
list <br>

SLL implementation of queues <br>
• In an SLL you can easily find the successor of a node, but not 
its predecessor <br>
Remember, pointers (references) are one-way <br>
• If you know where the last node in a list is, it’s hard to <br> 
remove that node, but it’s easy to add a node after it <br>
• Hence, <br>
Use the first element in an SLL as the front of the queue <br>
Use the last element in an SLL as the rear of the queue <br>
Keep pointers to both the front and the rear of the SLL <br>
<h3 style="color:red ;"> Enqueueing a node </h3><br>
17 <br>
Node to be <br>
enqueued <br>
To enqueue (add) a node: <br>
Find the current last node <br>
Change it to point to the new last node <br> 
Change the last pointer in the list header <br>
23 <br>
44 <br>
last <br>
first <br>
97 
<h3 style="color: red;"> Dequeueing a node </h3><br>

 To dequeue (remove) a node: <br>
 Copy the pointer from the first node into the header <br>
44 <br>
97 <br>
23 <br>
17 <br>
last <br>
first <br>
<h3 style="color: red;">Queue implementation details </h3> <br>
 With an array implementation: <br>
 you can have both overflow and underflow <br>
 you <br>
should <br>
set <br>
deleted <br>
elements <br>
to <br>
null <br>
 With a linked-list implementation: <br>
 you can have underflow <br>
 overflow is a global out-of-memory condition <br>
 there is no reason to set deleted elements to null <br>
 <h3 style="color: red;">Dequeues </h3> <br>
<li> A dequeue is a double-ended queue </li>
 <li> Insertions and deletions can occur at either end</li>
<li> Implementation is similar to that for queues </li>
<li> Deques are not heavily used </li>
<li> You should know what a deque is, but we won’t explore them much 
further </li>
</ul>


</div>

 </body>

</html>
